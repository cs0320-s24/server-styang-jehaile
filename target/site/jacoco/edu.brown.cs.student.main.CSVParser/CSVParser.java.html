<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CSVParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">s0</a> &gt; <a href="index.source.html" class="el_package">edu.brown.cs.student.main.CSVParser</a> &gt; <span class="el_source">CSVParser.java</span></div><h1>CSVParser.java</h1><pre class="source lang-java linenums">package edu.brown.cs.student.main.CSVParser;

import edu.brown.cs.student.main.Exceptions.FactoryFailureException;
import edu.brown.cs.student.main.Exceptions.MalformedRowsException;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;

/**
 * Class that parses an inputted Reader object to List&lt;T&gt; based on an inputted CreatorFromRow&lt;T&gt;
 * object
 *
 * @param &lt;T&gt; The type which each row of data is stored as in List&lt;T&gt; type csvContents field
 */
public class CSVParser&lt;T&gt; {
  private final Reader reader;
  private final CreatorFromRow&lt;T&gt; strategyObject;
  private final Boolean headers;
  private ArrayList&lt;String&gt; headerList;
  private List&lt;T&gt; csvContents;

  /**
   * Constructor for CSVParser object.
   *
   * @param reader a Reader object to be parsed
   * @param strategyObject a CreatorFromRow&lt;T&gt; object used to create object of type T from each row
   *     of reader
   * @param headers a Boolean indicating if headers are present in reader.
   */
<span class="nc" id="L34">  public CSVParser(Reader reader, CreatorFromRow&lt;T&gt; strategyObject, Boolean headers) {</span>
<span class="nc" id="L35">    this.reader = reader;</span>
<span class="nc" id="L36">    this.strategyObject = strategyObject;</span>
<span class="nc" id="L37">    this.headers = headers;</span>
<span class="nc" id="L38">  }</span>

  /**
   * Parses Reader file, assigning CSVParser's csvContents field a list of generic type T, where T
   * indicates the type generated by the Class's strategyObject's create() method for each inputted
   * row. If CSVParser's headers field is True, the parse() method will assign CSVParser's
   * headerList field an ArrayList of String storing the first row of the Reader file. If the Reader
   * file is empty, csvContents will be initiated as an empty list. If headers is True, headerList
   * will also be initiated as an empty list, otherwise it will remain unassigned. Uses the length
   * of the first line of CSVParser's reader field as the standard row size and skips invalid-sized
   * rows while parsing, storing them in malformedRows. If malformedRows is not empty at the end of
   * parsing each row, a MalformedRowsException will be thrown.
   *
   * @throws IOException parse() method throws IOException if encountering an error reading from
   *     Reader in CSVParser's reader field.
   * @throws FactoryFailureException parse() method throws FactoryFailureException if CreatorFromRow
   *     object encounters an error when converting row to generic type T
   * @throws MalformedRowsException parse() method throws MalformedRowsException after encountering
   *     rows that are the invalid size. Exception is thrown after parsing is completed
   */
  public void parse() throws IOException, FactoryFailureException, MalformedRowsException {
<span class="nc" id="L59">    BufferedReader bufferedReader = new BufferedReader(this.reader);</span>
<span class="nc" id="L60">    Pattern regexSplitCSVRow = Pattern.compile(&quot;,(?=([^\\\&quot;]*\\\&quot;[^\\\&quot;]*\\\&quot;)*(?![^\\\&quot;]*\\\&quot;))&quot;);</span>
<span class="nc" id="L61">    ArrayList&lt;List&lt;String&gt;&gt; malformedRows = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L62">    this.csvContents = new ArrayList&lt;&gt;();</span>

    // read first line
<span class="nc" id="L65">    String line = bufferedReader.readLine();</span>

    // empty file leaves csvContents field as an empty list. headersList also empty.
<span class="nc bnc" id="L68" title="All 2 branches missed.">    if (line == null) {</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">      if (headers) {</span>
<span class="nc" id="L70">        this.headerList = new ArrayList&lt;String&gt;();</span>
      }
<span class="nc" id="L72">      return;</span>
    }

    // assign rowSize based on first line, regardless of if headers are present
<span class="nc" id="L76">    int rowSize = Arrays.asList(regexSplitCSVRow.split(line)).size();</span>

    // build headerList if headers are present
<span class="nc bnc" id="L79" title="All 2 branches missed.">    if (this.headers) {</span>
<span class="nc" id="L80">      String[] headersArray = regexSplitCSVRow.split(line);</span>
<span class="nc" id="L81">      ArrayList&lt;String&gt; headerListBuilder = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">      for (String header : headersArray) {</span>
<span class="nc" id="L83">        headerListBuilder.add(header.toUpperCase());</span>
      }
<span class="nc" id="L85">      this.headerList = headerListBuilder;</span>

<span class="nc" id="L87">      line = bufferedReader.readLine();</span>
    }

    // while contents exist, parse each row
<span class="nc bnc" id="L91" title="All 2 branches missed.">    while (line != null) {</span>
<span class="nc" id="L92">      List&lt;String&gt; result = Arrays.asList(regexSplitCSVRow.split(line));</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">      if (result.size() == rowSize) {</span>
<span class="nc" id="L94">        this.csvContents.add(strategyObject.create(result));</span>
      } else {
        // if malformed rows exist, they are logged, but parsing continues (error thrown after)
<span class="nc" id="L97">        malformedRows.add(result);</span>
      }
<span class="nc" id="L99">      line = bufferedReader.readLine();</span>
<span class="nc" id="L100">    }</span>

<span class="nc" id="L102">    bufferedReader.close();</span>

    // inform that malformed rows exist and were not parsed
<span class="nc bnc" id="L105" title="All 2 branches missed.">    if (!malformedRows.isEmpty()) {</span>
<span class="nc" id="L106">      throw new MalformedRowsException(</span>
          &quot;Some rows could not be parsed due to invalid size&quot;, malformedRows);
    }
<span class="nc" id="L109">  }</span>

  /**
   * Getter method for CSVContents to be called after parse()
   *
   * @return List&lt;T&gt; containing parsed file contents or null if not parsed yet
   */
  public List&lt;T&gt; getCSVContents() {
<span class="nc" id="L117">    return this.csvContents;</span>
  }

  /**
   * Getter method for headerList to be called after parse()
   *
   * @return List&lt;String&gt; containing headers in order found in reader field or null if not parsed
   *     yet, or if headers field is False
   */
  public List&lt;String&gt; getHeaderList() {
<span class="nc" id="L127">    return this.headerList;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>